{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-the-calrissian-documentation-site","title":"Welcome to the Calrissian Documentation Site!","text":"<p>Calrissian is a cloud-native CWL runner designed for executing Common Workflow Language (CWL) workflows in containerized environments, particularly on Kubernetes. Whether you're working on bioinformatics, data science, or any domain requiring reproducible workflows, Calrissian provides the tools you need to scale and manage your workflows efficiently.</p> <p>Here, you'll find guides, tutorials, and reference materials to help you get started with Calrissian, configure your workflows, and optimize their performance in Kubernetes clusters. Whether you're new to CWL or an experienced user, our documentation will support you at every step of your journey with Calrissian.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#about-calrissian","title":"About Calrissian","text":"<p>Calrissian is a CWL implementation designed to run inside a Kubernetes cluster. Its goal is to be highly efficient and scalable, taking advantage of high capacity clusters to run many steps in parallel.</p> <p>It leverages cwltool to manage the execution of CWL workflows and triggers pods instead of containers. Here's a brief history of the Calrissian CWL runner:</p>"},{"location":"background/#history-and-development-of-calrissian-cwl-runner","title":"History and Development of Calrissian CWL Runner","text":""},{"location":"background/#inception-and-need","title":"Inception and Need","text":"<p>Early Days of CWL:</p> <p>The Common Workflow Language (CWL) was developed to provide a standardized way to describe workflows across various computing environments. CWL aimed to solve the problem of workflow portability and reproducibility in computational research.</p> <p>Containerization:</p> <p>As CWL gained traction, the need to run these workflows in containerized environments became apparent. Containers, with tools like Docker or podman, allowed for reproducible environments. However, traditional CWL runners were not optimized for containerized or cloud-native execution.</p>"},{"location":"background/#development-of-calrissian","title":"Development of Calrissian","text":"<p>Initial Development: </p> <p>Calrissian was created to fill the gap in running CWL workflows efficiently in Kubernetes clusters. The initial version was developed by the Duke Center for Genomic and Computational Biology in collaboration with other contributors from the CWL community.</p> <p>Open Source:</p> <p>Calrissian is open-source, and its development has been community-driven, with contributions from various developers and researchers in the CWL community.</p> <p>Features and Evolution:</p> <ul> <li>Kubernetes Integration: Calrissian leverages Kubernetes for resource allocation, scaling, and managing workflow tasks. It automatically schedules jobs, handles retries, and scales up resources as needed.</li> <li>CWL Compliance: Calrissian seeks to adhere strictly to the CWL standards, ensuring that workflows defined in CWL can be executed without modification.</li> <li>Performance Optimizations: Over time, Calrissian has seen several performance improvements, particularly in how it manages containerized jobs, handles data inputs/outputs, and integrates with Kubernetes features.</li> </ul> <p>Community Adoption:</p> <p>Calrissian has been adopted by various research institutions and companies that rely on CWL for their workflow management, especially in bioinformatics, computational biology and Earth Observation.</p> <p>Current Status:</p> <ul> <li>Active Development: As of now, Calrissian continues to be actively developed and maintained. It is widely used in the scientific community, particularly for workflows that require cloud-native execution.</li> <li>Growing Ecosystem: The ecosystem around CWL, including Calrissian, continues to grow, with more tools and integrations being developed to make workflow execution more seamless and efficient.</li> </ul>"},{"location":"background/#conclusion","title":"Conclusion","text":"<p>Calrissian CWL runner is a key tool for running CWL workflows in containerized environments like Kubernetes. Its development was driven by the need for a scalable, cloud-native solution for CWL workflows, and it has since become an essential tool in the CWL ecosystem. The ongoing contributions from the open-source community ensure that Calrissian remains a cutting-edge solution for managing CWL workflows in modern computational environments.</p>"},{"location":"cluster-configuration/","title":"Cluster Configuration","text":""},{"location":"cluster-configuration/#kubernetes-cluster-configuration","title":"Kubernetes cluster configuration","text":"<p>This page provides the configuration steps to run Calrissian jobs.</p>"},{"location":"cluster-configuration/#service-account","title":"Service account","text":"<p>It's a best practice to create a dedicated Service Account with a manifest like:</p> <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: calrissian-sa\n</code></pre>"},{"location":"cluster-configuration/#roles-and-role-bindings","title":"Roles and Role Bindings","text":"<p><code>calrissian</code> executes CWL workflows by running steps as Pods in a kubernetes cluster. </p> <p>Create the Roles to manage pods and pod logs:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pod-manager-role\nrules:\n- apiGroups: [\"\"] \n  resources: [\"pods\"]\n  verbs: [\"create\",\"patch\",\"delete\",\"list\",\"watch\",\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: log-reader-role\nrules:\n- apiGroups: [\"\"] \n  resources: [\"pods/log\"]\n  verbs: [\"get\",\"list\"]\n</code></pre> <p>Bind these roles to the <code>calrissian-sa</code> Service Account with the manifest: </p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pod-manager-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: pod-manager-role\nsubjects:\n- kind: ServiceAccount\n  name: calrissian-sa\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: log-reader-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: log-reader-role\nsubjects:\n- kind: ServiceAccount\n  name: calrissian-sa\n</code></pre>"},{"location":"cluster-configuration/#persistent-volume-claim","title":"Persistent Volume Claim","text":"<p>Calrissian needs a ReadWriteMany volume than can be defined with:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: calrissian-claim\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 10G\n  storageClassName: default\n</code></pre> <p>Note: Update the <code>storageClassName</code> according to the Kubernetes cluster.</p>"},{"location":"how-it-works/","title":"How it works","text":""},{"location":"how-it-works/#environment","title":"Environment","text":"<p>Calrissian process must run in a pod in a kubernetes cluster.</p> <p>This process must have an environment variable name CALRISSIAN_POD_NAME used by Calrissian to identify the Pod in which it is running. </p> <p>Calrissian uses this information to list the volumes mounted on the current Pod and to \"re-mount\" these volumes on the Pods that will be created for running individual CWL tools. </p> <p>This ensures that the tools have access to the necessary files and directories specified in the CWL workloads.</p>"},{"location":"how-it-works/#scalability-resource-requirements","title":"Scalability / Resource Requirements","text":"<p>Calrissian is designed to issue tasks in parallel if they are independent, and thanks to Kubernetes, should be able to run very large parallel workloads.</p> <p>When running calrissian, you must provide a limit the the number of CPU cores (<code>--max-cores</code>), RAM megabytes (<code>--max-ram</code>) and GPU (<code>--max-gpu</code>) to use concurrently. Calrissian will use CWL ResourceRequirements to track usage and stay within the limits provided. </p> <p>It is highly recommended using accurate ResourceRequirements in the workloads, so that they can be scheduled efficiently and are less likely to be terminated or refused by the cluster.</p>"},{"location":"how-it-works/#cpu","title":"CPU","text":"<p>The <code>--max-cores</code> option sets the maximum number of CPU cores that Calrissian can use during the execution of a workflow. This value is specified as an integer, representing the total number of CPU cores allocated across all the Pods managed by Calrissian.</p> <p>How it works:</p> <ul> <li>Calrissian tracks the total number of CPU cores being utilized by all active Pods.</li> <li>Pods are scheduled to run on the cluster as long as the cumulative CPU usage remains below the specified <code>--max-cores</code> limit.</li> <li>If starting a new Pod would cause the total CPU usage to exceed this limit, the Pod will remain in a pending state until sufficient CPU resources are freed by the completion or termination of other Pods.</li> </ul> <p>This option is crucial for managing CPU resources effectively within a Kubernetes environment, ensuring that the workflow does not overcommit CPU resources, which could lead to performance issues or throttling by the Kubernetes scheduler.</p>"},{"location":"how-it-works/#memory","title":"Memory","text":"<p>The <code>--max-ram</code> option sets the maximum amount of RAM that Calrissian can use during the execution of a workflow. This value can be specified in bytes (e.g., 1048576), mebibytes (e.g., 512Mi), or gigabytes (e.g., 2G), following Kubernetes (k8s) resource conventions.</p> <p>How it works:</p> <ul> <li>Calrissian monitors the total RAM consumption of all the Pods it manages.</li> <li>Pods are created and scheduled to run on the cluster as long as the cumulative RAM usage remains below the specified <code>--max-ram</code> limit.</li> <li>If launching a new Pod would exceed this limit, the Pod remains in a pending state until sufficient resources are freed by the completion or termination of other Pods.</li> </ul> <p>This mechanism ensures that the workflow adheres to the specified memory constraints, preventing over-allocation of resources that could lead to performance degradation or failures in a Kubernetes environment.</p>"},{"location":"how-it-works/#gpu","title":"GPU","text":"<p>The <code>--max-gpus</code> option sets the maximum number of GPU cores that Calrissian can utilize during the execution of a workflow. This value is specified as an integer, representing the total number of GPU nodes available for allocation across all Pods managed by Calrissian.</p> <p>How it works:</p> <ul> <li>Calrissian monitors the total number of GPU cores in use by all active Pods.</li> <li>Pods that require GPU resources are scheduled to run on the cluster as long as the cumulative GPU usage remains below the specified <code>--max-gpus</code> limit.</li> <li>If launching a new Pod would exceed this GPU limit, the Pod remains in a pending state until sufficient GPU resources are freed by the completion or termination of other Pods.</li> </ul> <p>This option is essential for workflows that involve GPU-intensive tasks, such as machine learning or scientific computations, ensuring that GPU resources are managed effectively and preventing over-allocation that could lead to resource contention or job failures.</p>"},{"location":"how-it-works/#resource-consumption-report","title":"Resource consumption report","text":"<p>The <code>--usage-report</code> option specifies the path to a JSON file where Calrissian will record detailed resource usage metrics and job outcomes during the execution of a workflow. This report provides valuable insights into how resources were utilized and the performance of each task within the workflow.</p> <p>What it includes:</p> <ul> <li>CPU Cores: The total number of CPU cores used by each Pod during its execution.</li> <li>RAM Usage: The amount of RAM consumed by each Pod throughout its lifecycle.</li> <li>GPU Usage (if applicable): The number of GPU cores utilized by Pods, relevant if the workflow involves GPU resources.</li> <li>Exit Codes: The exit codes returned by each Pod, indicating the success or failure of the tasks they performed.</li> </ul> <p>How it works:</p> <p>Throughout the workflow execution, Calrissian tracks the resource usage and exit codes of all Pods it manages.</p> <p>Upon completion, Calrissian compiles this data into a JSON file at the location specified by the <code>--usage-report</code> option.</p> <p>This JSON report can be used for post-execution analysis, helping users understand resource allocation, optimize future runs, and troubleshoot any issues that may have occurred.</p> <p>This option is particularly useful for monitoring and optimizing workflows, as it provides a comprehensive overview of how resources were consumed during execution, as well as the success or failure of each task.</p>"},{"location":"how-it-works/#cwl-execution-results","title":"CWL execution results","text":"<p>The <code>--stdout</code> option specifies the file where Calrissian will dump the standard output produced by the CWL (Common Workflow Language) execution, which typically includes the results or outputs generated by the workflow.</p> <p>How it works:</p> <p>During the execution of a CWL workflow, various tools and steps produce outputs. These outputs, often formatted as JSON, describe the results of the workflow, including any files, data, or other artifacts generated.</p> <p>The <code>--stdout</code> option directs this output to a specified file, rather than displaying it directly in the terminal.</p> <p>By capturing the output in a file, users can easily access and review the results after the workflow completes.</p> <p>Benefits:</p> <ul> <li>Convenience: Storing output in a file allows for easy access and review, especially for large outputs that may be cumbersome to read in the terminal.</li> <li>Post-processing: The output file can be used for further processing, such as parsing the results with scripts, sharing the file with collaborators, or integrating with other tools.</li> <li>Record-keeping: The output file serves as a permanent record of the workflow results, which can be useful for documentation or reproducibility.</li> </ul> <p>This option is essential for workflows where the output data is important for further analysis, sharing, or archiving, ensuring that the results are captured in a structured and accessible format.</p>"},{"location":"how-it-works/#calrissian-execution-log","title":"Calrissian execution log","text":"<p>The <code>--stderr</code> option specifies the file where Calrissian will log the standard error output, which includes detailed execution logs of the Calrissian process, as well as any error messages, warnings, or diagnostic information generated during the workflow execution.</p> <p>How it works:</p> <p>During the execution of a CWL (Common Workflow Language) workflow, Calrissian generates various log entries and error messages that are normally output to the terminal's standard error stream.</p> <p>The <code>--stderr</code> option directs this standard error output to a specified file, ensuring that all relevant logs and error information are captured for review.</p> <p>This log file contains critical information about the workflow execution, including any issues that occurred, steps performed, and resource usage details, making it an invaluable resource for debugging and auditing.</p> <p>Benefits:</p> <ul> <li>Debugging: By capturing standard error output in a file, users can systematically review the logs to diagnose and resolve any issues that may have occurred during the workflow execution.</li> <li>Execution Trace: The log provides a step-by-step trace of the execution process, which is useful for understanding how the workflow was processed and where any potential bottlenecks or failures might have occurred.</li> <li>Audit Trail: The log file serves as an audit trail, documenting the workflow execution in detail, which can be important for compliance, reproducibility, or record-keeping.</li> </ul> <p>This option is crucial for maintaining a clear and accessible record of the Calrissian execution process, enabling users to troubleshoot problems, monitor the workflow, and ensure that everything runs as expected.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Calrissian is available at: https://pypi.org/project/calrissian/</p> <p>Install it in your own container images with:</p> <pre><code>RUN pip install calrissian\n</code></pre>"},{"location":"conformance/1.0.2/","title":"1.0.2","text":""},{"location":"conformance/1.0.2/#conformance-tests-for-cwl-v10-for-the-latest-release","title":"Conformance tests for CWL v1.0 for the latest release","text":""},{"location":"conformance/1.0.2/#classes","title":"Classes","text":""},{"location":"conformance/1.0.2/#required-features","title":"Required features","text":""},{"location":"conformance/1.0.2/#optional-features","title":"Optional features","text":""},{"location":"conformance/1.0.2/#conformance-output","title":"Conformance output","text":"<p>result-v1.0.txt</p>"},{"location":"conformance/1.1.0/","title":"1.1.0","text":""},{"location":"conformance/1.1.0/#conformance-tests-for-cwl-v11-for-the-latest-release","title":"Conformance tests for CWL v1.1 for the latest release","text":""},{"location":"conformance/1.1.0/#classes","title":"Classes","text":""},{"location":"conformance/1.1.0/#required-features","title":"Required features","text":""},{"location":"conformance/1.1.0/#optional-features","title":"Optional features","text":""},{"location":"conformance/1.2.0/","title":"1.2.0","text":""},{"location":"conformance/1.2.0/#conformance-tests-for-cwl-v120-for-the-latest-release","title":"Conformance tests for CWL v1.2.0 for the latest release","text":""},{"location":"conformance/1.2.0/#classes","title":"Classes","text":""},{"location":"conformance/1.2.0/#required-features","title":"Required features","text":""},{"location":"conformance/1.2.0/#optional-features","title":"Optional features","text":""},{"location":"conformance/1.2.1/","title":"1.2.1","text":""},{"location":"conformance/1.2.1/#conformance-tests-for-cwl-v121-proposed-for-the-latest-release","title":"Conformance tests for CWL v1.2.1 (proposed) for the latest release","text":""},{"location":"conformance/1.2.1/#classes","title":"Classes","text":""},{"location":"conformance/1.2.1/#required-features","title":"Required features","text":""},{"location":"conformance/1.2.1/#optional-features","title":"Optional features","text":""},{"location":"how-to/save-tool-logs/","title":"Save the tool logs","text":""},{"location":"how-to/save-tool-logs/#how-to-save-the-tool-logs","title":"How to save the tool logs","text":"<p>The <code>--tool-logs-basepath</code> option specifies the base directory path where Calrissian will save the logs generated by each CWL (Common Workflow Language) tool during the execution of a workflow. </p> <p>These logs capture detailed information about the execution of each tool, which can be critical for debugging, monitoring, and auditing purposes.</p> <p>During the execution of a CWL workflow, each tool that is run as part of the workflow may produce logs. These logs include standard output, standard error, and any other tool-specific logging information.</p> <p>The <code>--tool-logs-basepath</code> option allows you to define a base directory where all these logs will be stored. </p> <p>Calrissian organizes the logs within this directory, typically creating subdirectories for each tool or task. By setting this path, you ensure that all tool logs are centrally located and easily accessible for post-execution review.</p>"},{"location":"how-to/save-tool-logs/#usage-example","title":"Usage Example","text":"<pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --tool-logs-basepath \n            - /calrissian/logs\n            ...\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n  backoffLimit: 3\n</code></pre>"},{"location":"how-to/set-node-selectors/","title":"Set node selectors","text":""},{"location":"how-to/set-node-selectors/#how-to-set-node-selectors","title":"How to set node selectors","text":"<p>The <code>--pod-nodeselectors</code> option allows you to specify a YAML file that defines node selectors for the Kubernetes Pods created by Calrissian during the execution of a workflow. </p> <p>Node selectors are key-value pairs that constrain the scheduling of Pods to specific nodes in the Kubernetes cluster that match the specified criteria.</p> <p>The YAML file provided to the <code>--pod-nodeselectors</code> option should contain a list of key-value pairs that represent the node selector criteria.</p> <p>When Calrissian creates Pods to run CWL tools, it applies these node selectors to ensure that the Pods are scheduled only on nodes that match the specified criteria.</p> <p>This option is useful when you need to run certain workloads on specific types of nodes, such as nodes with specific hardware, geographic location, or other attributes.</p>"},{"location":"how-to/set-node-selectors/#usage-example","title":"Usage Example:","text":"<pre><code>k8s.earth.com/pool-name: processing-node-pool-gpu\n</code></pre> <p>If this file is available in the <code>/calrissian</code> mount point, then in your Calrissian Job manifest do:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --pod-nodeselectors\n            - /calrissian/node-selector.yaml\n            ...\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n  backoffLimit: 3\n</code></pre> <p>If you want to mount it via a Config Map, create a ConfigMap named <code>node-selector</code> in the calrissian namespace using the <code>node-selector.yaml</code> file:</p> <pre><code>kubectl create -n calrissian configmap node-selector --from-file=node-selector.yaml\n</code></pre> <p>and then do:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --pod-nodeselectors\n            - /selector/node-selector.yaml\n            ...\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n            - name: node-selector-volume\n              mountPath: /selector\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n        - name: node-selector-volume\n          configMap:\n            name: node-selector\n  backoffLimit: 3\n</code></pre>"},{"location":"how-to/set-pod-labels/","title":"Set pod labels","text":""},{"location":"how-to/set-pod-labels/#how-to-set-pod-labels","title":"How to set pod labels","text":"<p>The <code>--pod-labels</code> option allows you to specify a YAML file that contains key-value pairs for labels to be applied to the Kubernetes Pods created by Calrissian during the execution of a workflow. </p> <p>These labels can be used for organizing, categorizing, and managing the Pods within the Kubernetes cluster.</p> <p>The YAML file provided to the <code>--pod-labels</code> option should contain a list of key-value pairs that represent the labels you want to apply to the Pods.</p> <p>When Calrissian creates Pods to run CWL tools, it automatically applies the specified labels to these Pods.</p> <p>Labels can be used for various purposes, such as grouping related Pods, filtering Pods during monitoring, or applying policies within the cluster.</p>"},{"location":"how-to/set-pod-labels/#usage-example","title":"Usage Example","text":"<p>Create a <code>pod-labels.yaml</code> file with the following content:</p> <pre><code>app: water-bodies-detection\nenvironment: production\nworkflow: sentinel-2-processing\n</code></pre> <p>If this file is available in the <code>/calrissian</code> mount point, then in your Calrissian Job manifest do:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --pod-labels\n            - /calrissian/pod-labels.yaml\n            ...\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n  backoffLimit: 3\n</code></pre> <p>If you want to mount it via a Config Map, create a ConfigMap named <code>pod-labels</code> in the calrissian namespace using the <code>pod-labels.yaml</code> file:</p> <pre><code>kubectl create -n calrissian configmap pod-labels --from-file=pod-labels.yaml\n</code></pre> <p>and then do:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --pod-labels\n            - /labels/pod-labels.yaml\n            ...\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n            - name: pod-labels-volume\n              mountPath: /labels\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n        - name: pod-labels-volume\n          configMap:\n            name: pod-labels\n  backoffLimit: 3\n</code></pre>"},{"location":"reference/cli/","title":"Calrissian Command-Line Tool Reference","text":"<p><code>calrissian</code> command-line tool reuses and extends the <code>cwltool</code> command-line tool interface.</p>"},{"location":"reference/cli/#cwltool-mandatory-cli-options","title":"cwltool mandatory cli options","text":"<p><code>calrissian</code> command-line tool reuses the <code>cwltool</code> command-line tool interface.</p> <p>These options described below are mandatory when using <code>calrissian</code>.</p>"},{"location":"reference/cli/#-tmp-outdir-prefix","title":"--tmp-outdir-prefix","text":"<p><code>--tmp-outdir-prefix</code> sets the prefix for temporary output directories.</p> <p>When a CWL tool or workflow is executed, <code>calrissian</code> creates temporary directories to store intermediate output files. </p> <p>By default, these directories are created in the system's temporary directory (e.g., <code>/tmp/</code>).</p> <p>The <code>--tmp-outdir-prefix</code> option allows you to specify a custom prefix for these temporary directories in the ReadWriteMany volume, which can be useful for organizing or controlling the location of these directories.</p>"},{"location":"reference/cli/#-outdir","title":"--outdir","text":"<p><code>--outdir</code> specifies the output directory for final results.</p> <p>When cwltool completes the execution of a workflow or tool, the final output files are stored in a designated directory. </p> <p>The <code>--outdir</code> option allows you to define the location of this output directory in the ReadWriteMany volume.</p>"},{"location":"reference/cli/#calrissian-extended-cli-options","title":"calrissian extended cli options","text":"<p><code>calrissian</code> command-line tool extends the <code>cwltool</code> command-line tool interface.</p> <p>These options are described below.</p>"},{"location":"reference/cli/#-max-ram","title":"--max-ram","text":"<p><code>--max-ram</code> sets the maximum amount of RAM to use, e.g., 1048576, 512Mi, or 2G. Follows Kubernetes (k8s) resource conventions.</p> <p>Calrissian spawns pods until the max RAM value is reached. Remaining pods remain pending until resources are freed or procured.</p>"},{"location":"reference/cli/#-max-cores","title":"--max-cores","text":"<p><code>--max-cores</code> sets the maximum number of CPU cores to use.</p> <p>This option limits the number of CPU cores available for the pods. If the specified number of cores is exceeded, additional pods will be queued until resources are available.</p>"},{"location":"reference/cli/#-max-gpus","title":"--max-gpus","text":"<p><code>--max-gpus</code> sets the maximum number of GPU cores to use.</p> <p>This option is optional and, if provided, limits the GPU resources available for the pods. If the specified number of GPU cores is exceeded, additional pods will be queued until resources are available.</p>"},{"location":"reference/cli/#-pod-labels","title":"--pod-labels","text":"<p><code>--pod-labels</code> allows the user to specify a YAML file containing labels to add to the Pods submitted.</p> <p>These labels can be used to categorize, organize, or manage the Pods in the Kubernetes environment.</p>"},{"location":"reference/cli/#-pod-env-vars","title":"--pod-env-vars","text":"<p><code>--pod-env-vars</code> allows the user to specify a YAML file containing environment variables to add at runtime to the Pods submitted.</p> <p>This is useful for injecting configuration values or secrets into the pod environments.</p>"},{"location":"reference/cli/#-pod-nodeselectors","title":"--pod-nodeselectors","text":"<p><code>--pod-nodeselectors</code> allows the user to specify a YAML file containing node selectors to add to the Pods submitted.</p> <p>Node selectors constrain the Pods to run only on specific nodes within the Kubernetes cluster that match the specified criteria.</p>"},{"location":"reference/cli/#-pod-serviceaccount","title":"--pod-serviceaccount","text":"<p><code>--pod-serviceaccount</code> sets the Service Account to use for pods management.</p> <p>The Service Account defines the permissions and access controls for the Pods running in the Kubernetes cluster.</p>"},{"location":"reference/cli/#-usage-report","title":"--usage-report","text":"<p><code>--usage-report</code> specifies the output JSON file name to record resource usage.</p> <p>This file contains details on the resource utilization (CPU, RAM, GPU, etc.) of the Pods during execution, which can be used for monitoring and optimization purposes.</p>"},{"location":"reference/cli/#-stdout","title":"--stdout","text":"<p><code>--stdout</code> specifies the output file name to tee standard output (CWL output object).</p> <p>This option captures the standard output of the tool and saves it to the specified file, in addition to displaying it in the console.</p>"},{"location":"reference/cli/#-stderr","title":"--stderr","text":"<p><code>--stderr</code> specifies the output file name to tee standard error to (includes tool logs).</p> <p>This option captures the standard error output, including logs, and saves it to the specified file, in addition to displaying it in the console.</p>"},{"location":"reference/cli/#-tool-logs-basepath","title":"--tool-logs-basepath","text":"<p><code>--tool-logs-basepath</code> sets the base path for saving the tool logs.</p> <p>This option defines the directory where the tool's log files will be stored. It helps in organizing logs by location.</p>"},{"location":"reference/cli/#-conf","title":"--conf","text":"<p><code>--conf</code> allows the user to define the default values for the CLI arguments.</p> <p>This option can be used multiple times to override or set default values for the various command-line options, simplifying repeated use cases.</p>"},{"location":"tutorial/calrissian-cli/","title":"Calrissian Cli","text":""},{"location":"tutorial/calrissian-cli/#calrissian-tutorial-running-a-water-bodies-detection-job-on-kubernetes","title":"Calrissian Tutorial: Running a Water Bodies Detection Job on Kubernetes","text":"<p>This tutorial guides you through the steps to running Calrissian as a Cli in a kubernete pod.</p> <p>This requires creating a pod with the <code>calrissian</code> executable installed and opening a shell in that pod.</p> <p>This tutorial targets a minikube cluster.</p>"},{"location":"tutorial/calrissian-cli/#configure-minikube","title":"Configure minikube","text":"<p>Configure minikube to run calrissian:</p> <pre><code>curl -L https://calrissian-cwl.github.io/tutorial/assets/pvc.yaml | kubectl apply -n calrissian -f -\ncurl -L https://calrissian-cwl.github.io/tutorial/assets/service-account.yaml | kubectl apply -n calrissian -f -\ncurl -L https://calrissian-cwl.github.io/tutorial/assets/roles.yaml | kubectl apply -n calrissian -f -\ncurl -L https://calrissian-cwl.github.io/tutorial/assets/role-binding.yaml | kubectl apply -n calrissian -f -\n</code></pre>"},{"location":"tutorial/calrissian-cli/#step-1-create-a-container-with-calrissian","title":"Step 1: Create a Container with calrissian","text":"<p>Below an example of a Dockerfile that suits the tutorial needs:</p> <pre><code>FROM docker.io/python:3.10-slim-bullseye\n\n# Install necessary packages\nRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\\n    git \\\n    curl \\\n    wget \\\n    vim \\\n    sudo &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# Install kubectl\nRUN curl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" &amp;&amp; \\\n    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl &amp;&amp; \\\n    rm kubectl\n\n# Create a user named 'calrissian' with sudo privileges\nRUN useradd -m calrissian &amp;&amp; \\\n    echo \"calrissian:password\" | chpasswd &amp;&amp; \\\n    adduser calrissian sudo &amp;&amp; \\\n    echo \"calrissian ALL=(ALL) NOPASSWD:ALL\" &gt;&gt; /etc/sudoers\n\n# Add requirements.txt and install Python dependencies\nADD requirements.txt /tmp/requirements.txt\n\nRUN pip install --no-cache-dir calrissian\n\n# Set the user to 'calrissian'\nUSER calrissian\n\n# Add alias for ll=\"ls -l\" to the bash profile of calrissian\nRUN echo 'alias ll=\"ls -l\"' &gt;&gt; /home/calrissian/.bashrc\n\nWORKDIR /home/calrissian\n</code></pre> <p>Build the image with:</p> <pre><code>docker build -t calrissian-runtime -f Dockerfile .\n</code></pre> <p>Push the image to minikube:</p> <pre><code>minikube image load docker.io/library/calrissian-runtime\n</code></pre>"},{"location":"tutorial/calrissian-cli/#step-2-create-a-deployment-with-a-pod","title":"Step 2: Create a Deployment with a pod","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: calrissian-session\n  labels:\n    app: calrissian\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: calrissian\n  template:\n    metadata:\n      labels:\n        app: calrissian\n    spec:\n      serviceAccountName: calrissian-sa\n      containers:\n        - name: calrissian-session\n          image: docker.io/library/calrissian-runtime \n          command: [\"sleep\", \"infinity\"]\n          volumeMounts:\n            - mountPath: /calrissian\n              name: calrissian-volume\n          resources:\n            limits:\n              cpu: '2'\n              memory: 1Gi\n            requests:\n              cpu: '1'\n              memory: 512Mi\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim\n</code></pre> <p>Deploy it with:</p> <pre><code>curl -L https://calrissian-cwl.github.io/tutorial/assets/deployment.yaml | kubectl apply -n calrissian -f -\n</code></pre>"},{"location":"tutorial/k8s-job/","title":"Calrissian Job","text":""},{"location":"tutorial/k8s-job/#calrissian-tutorial-running-a-water-bodies-detection-job-on-kubernetes","title":"Calrissian Tutorial: Running a Water Bodies Detection Job on Kubernetes","text":"<p>This tutorial guides you through the steps to set up and run a Calrissian job on Kubernetes for detecting water bodies using Sentinel-2 imagery. </p> <p>The workflow is packaged as a CWL (Common Workflow Language) file, and the necessary configurations are stored in ConfigMaps.</p>"},{"location":"tutorial/k8s-job/#prerequisites","title":"Prerequisites","text":"<p>A running Kubernetes cluster with <code>kubectl</code> configured with:</p> <ul> <li>A Kubernetes namespace named <code>calrissian</code></li> <li>A Kubernetes service account <code>calrissian-sa</code></li> <li>Roles and role bindings mounted on the service account</li> <li>A ReadWriteMany claim and volume</li> </ul>"},{"location":"tutorial/k8s-job/#step-1-create-the-parameters-file-configmap","title":"Step 1: Create the Parameters File ConfigMap","text":"<p>First, create a ConfigMap that contains the input parameters for the workflow, such as the STAC items (Sentinel-2 imagery) and the area of interest (AOI).</p> <ol> <li>Create a <code>params.yaml</code> file with the following content:</li> </ol> <pre><code>stac_items:\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_10TFK_20210708_0_L2A\"\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2B_10TFK_20210713_0_L2A\"\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_10TFK_20210718_0_L2A\"\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_10TFK_20220524_0_L2A\"\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_10TFK_20220514_0_L2A\"\n- \"https://earth-search.aws.element84.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_10TFK_20220504_0_L2A\"\naoi: -121.399,39.834,-120.74,40.472\nepsg: \"EPSG:4326\"\n</code></pre> <ol> <li>Create a ConfigMap named <code>params</code> in the calrissian namespace using the <code>params.yaml</code> file:</li> </ol> <pre><code>kubectl create -n calrissian configmap params --from-file=params.yaml\n</code></pre>"},{"location":"tutorial/k8s-job/#step-2-get-the-application-package","title":"Step 2: Get the Application Package","text":"<p>Next, download the CWL application package and create another ConfigMap to store it.</p> <p>Download the CWL workflow file:</p> <pre><code>curl -L https://github.com/eoap/mastering-app-package/releases/download/1.0.0/app-water-bodies-cloud-native.1.0.0.cwl &gt; app-package.cwl\n</code></pre> <p>Create a ConfigMap named app-package in the calrissian namespace using the app-package.cwl file:</p> <pre><code>kubectl create -n calrissian configmap app-package --from-file=app-package.cwl\n</code></pre>"},{"location":"tutorial/k8s-job/#step-3-prepare-the-kubernetes-job-manifest","title":"Step 3: Prepare the Kubernetes Job Manifest","text":"<p>The Kubernetes Job manifest defines how the workflow will be executed. </p> <p>The manifest includes configurations for the Calrissian container, resource limits, and the volumes needed to store input and output data.</p> <p>Here is the job manifest:</p> <pre><code>---\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: water-bodies-detection\nspec:\n  ttlSecondsAfterFinished: 60\n  template:\n    spec:\n      serviceAccountName: calrissian-sa\n      securityContext:\n        runAsUser: 1000\n        runAsGroup: 1000\n      containers:\n        - name: calrissian\n          image: ghcr.io/duke-gcb/calrissian/calrissian:0.16.0\n          command: [\"calrissian\"]\n          args:\n            - --stdout \n            - /calrissian/results.json\n            - --stderr \n            - /calrissian/app.log\n            - --max-ram \n            - 4G\n            - --max-cores \n            - \"8\"\n            - --tmp-outdir-prefix \n            - /calrissian/tmp/ \n            - --outdir\n            - /calrissian/results\n            - --usage-report \n            - /calrissian/usage.json\n            - --tool-logs-basepath \n            - /calrissian/logs\n            - /app-package/app-package.cwl\n            - /inputs/params.yaml\n          volumeMounts:\n            - name: calrissian-volume\n              mountPath: /calrissian\n            - name: params-volume\n              mountPath: /inputs\n            - name: app-package-volume\n              mountPath: /app-package\n          env:\n            - name: CALRISSIAN_POD_NAME\n              valueFrom:\n                fieldRef:\n                  fieldPath: metadata.name\n      restartPolicy: Never\n      volumes:\n        - name: calrissian-volume\n          persistentVolumeClaim:\n            claimName: calrissian-claim \n        - name: params-volume\n          configMap:\n            name: params  \n        - name: app-package-volume\n          configMap:\n            name: app-package\n  backoffLimit: 3\n</code></pre>"},{"location":"tutorial/k8s-job/#step-4-run-the-kubernetes-job","title":"Step 4: Run the Kubernetes Job","text":"<p>Apply the job manifest to start the Calrissian job in Kubernetes:</p> <pre><code>kubectl apply -n calrissian -f k8s-job.yaml\n</code></pre> <p>This command submits the job to the Kubernetes cluster, where Calrissian will execute the CWL workflow defined in the app-package.cwl file using the parameters from params.yaml.</p>"},{"location":"tutorial/k8s-job/#step-5-monitor-the-job","title":"Step 5: Monitor the Job","text":"<p>You can monitor the progress of the job by watching the Pods created by the job:</p> <pre><code>kubectl get pods -n calrissian -l job-name=water-bodies-detection -w\n</code></pre> <p>This command watches the Pods in real-time, displaying their status as they move through the lifecycle stages of Pending, Running, and Completed.</p>"},{"location":"tutorial/k8s-job/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully set up and run a Calrissian job on Kubernetes. The workflow processes Sentinel-2 imagery to detect water bodies within the specified area of interest. The outputs and logs are stored in the configured volumes, and the resource usage report provides detailed insights into the execution.</p>"}]}